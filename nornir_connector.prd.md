# Модуль NornirConnector

## Цель

Модуль `NornirConnector` обеспечивает централизованное и стандартизированное подключение к сетевым устройствам для выполнения команд по SSH (или аналогичным протоколам CLI) посредством фреймворка [Nornir](https://nornir.tech/).

---

## Основные принципы и требования

### 1. **Поддержка только программного (словарь) inventory**

- Конструктор модуля принимает только inventory в виде Python-словаря (Dict[имя устройства, параметры]).
- Чтение/парсинг YAML/JSON файлов inventory не поддерживается и не планируется.
- Заполнение inventory выполняется внешним кодом.
- Поддержка Netmiko extras (например, `fast_cli`, `session_log` через `connection_options`).

### 2. **Поддержка кастомных настроек хоста**

- В inventory можно добавлять поле `data` для хоста, чтобы адаптировать поведение задач.
- Пример: поддержка автоматической обработки пагинации для устройств с промптами вроде `--More--`.  
  Настройка: `'data': {'pagination': {'prompt_pattern': r'--More--', 'response': ' ', 'idle_timeout': 3.0}}`.  
  Это позволяет параллельно обрабатывать гетерогенные устройства без изменения публичного API.
- Поддержка произвольных pre/post-команд (hooks) для выполнения перед/после основной команды. Это реализовано через универсальный диспетчер задач, который автоматически обрабатывает конфигурационные и exec-команды (например, отключение/включение logging console для чистоты вывода). Настройки hooks передаются через `data.platform_config.hooks` в inventory.

---

### 3. **Настройка учётных данных**

- Учетные данные (`username`, `password`) для устройств **не** задаются внутри модуля и передаются только через inventory словарь.
- Не допускается хранить логины и пароли в коде, файлах конфигурации или как аргументы методов.
- Проект, использующий `NornirConnector`, должен получать эти значения из переменных окружения или секрет-хранилищ на своей стороне.

---

### 4. **Явное создание экземпляров (No Singleton)**

- Модуль не использует паттерн Singleton. Каждый экземпляр создаётся явно через `__init__` и управляется вызывающим кодом.
- Это позволяет использовать несколько независимых экземпляров в одном процессе (например, для разных наборов устройств).
- Жизненный цикл объекта контролируется внешне: после использования экземпляр уничтожается, автоматически закрывая соединения через `__del__`.

---

### 5. **Минимализм и универсальность API**

- Публичный интерфейс модуля ограничен одним основным методом для запуска команд:
    - `run_commands(command: str, hosts: Optional[List[str]], **kwargs)`
    - Поддержка только одной команды за вызов. Для нескольких команд используйте цикл.
- Не допускается добавление методов, специализированных на какие-либо сетевые команды или пост-обработку вывода (parse_mac_table, parse_arp_table, и т.д.).
- Работа с результатами полностью перекладывается на вызывающий скрипт (в модуле нет поля для хранения результатов или кэша результатов).
- Внутренняя обработка гетерогенных устройств (например, с пагинацией или hooks) обеспечивается универсальным диспетчером задач для параллельного выполнения.

---

### 6. **Прозрачная обработка ошибок**

- Логирование ошибок осуществляется через внешний логгер (передается извне либо импортируется общий).
- Исключения при критических ошибках пробрасываются вызывающему.
- Для неудачных хостов (no connect/command failed) результаты вызова содержат информацию об ошибке в стандартных полях объекта Nornir (`failed`, `exception` и пр.).
- Для задач с пагинацией ошибки (например, таймаут) логируются с детализацией (pages_processed, bytes).

---

### 7. **Никогда не хранит конфиденциальные данные**

- В исходных файлах и примерах модуля не содержатся пароли, токены, реальные адреса или иные чувствительные сведения.
- Все реальные реквизиты передаются через inventory, собираемый на основании внешних конфигов/секретов.

---

### 8. **Требования к совместимости**

- Совместим с [nornir 3.x](https://github.com/nornir-automation/nornir).
- Использует пакет `nornir_netmiko` для задач CLI.
- Поддержка только Threaded Runner (асинхронность/расширенный респонс поддерживать не требуется).

---

## Пример типового inventory для передачи коннектору

```python
inventory = {
    'sw1': {
        'hostname': '10.1.1.1',
        'platform': 'cisco_ios',
        'username': os.getenv('DEVICE_USERNAME'),
        'password': os.getenv('DEVICE_PASSWORD'),
    },
    'sw2': {
        'hostname': '10.2.2.2',
        'platform': 'huawei',
        'username': os.getenv('DEVICE_USERNAME'),
        'password': os.getenv('DEVICE_PASSWORD'),
    },
    'zyxel-host': {
        # ... другие поля
        'connection_options': {
            'netmiko': {
                'extras': {
                    'fast_cli': False,
                    'session_log': 'zyxel-host_session.log'  # Лог сессии для отладки
                }
            }
        }
    },
    'cisco-host': {
        'hostname': '192.168.1.1',
        'platform': 'cisco_ios',
        'username': os.getenv('DEVICE_USERNAME'),
        'password': os.getenv('DEVICE_PASSWORD'),
        'data': {
            'pagination': {
                'prompt_pattern': r'--More--',
                'response': ' ',
                'idle_timeout': 3.0
            },
            'platform_config': {
                'hooks': {  # ← Пример pre/post-команд для отключения logging console
                    'pre_cfg': ["conf t", "no logging console", "end"],
                    'post_cfg': ["conf t", "logging console", "end"]
                }
            }
        }
    }
}
```

---

## Пример сценария использования

```python
from typing import Optional, List
from custom_modules.nornir_connector import NornirConnector

# Инициализация через __init__
nr = NornirConnector(hosts_dict=inventory)

# Выполнение команды
results = nr.run_commands(command="show mac address-table", hosts=None)  # Или укажите hosts: List[str]

# Обработка результатов (results: Dict[str, Dict[str, Any]])
for hostname, result in results["show mac address-table"].items():
    if str(result).startswith("ERROR:"):
        print(f"{hostname} failed: {result}")
    else:
        print(f"{hostname} succeeded:\n{result}")

# Закрытие соединений (автоматически в __del__, но можно явно)
nr.close_connections()
```

---

## Ограничения и требования по безопасности

- Вся передача и инициализация чувствительных данных (логины/пароли) осуществляется вне рамок этого модуля.
- Не реализуется ни одно средство обхода контроля доступа, ни временное хранение данных, способных к компрометации секретов.

---

## Поддержка
- Любое расширение/уточнение ответственности модуля требует обновления данного `prd`.
- Все изменения должны быть промаркированы в changelog.

## Changelog
- **Версия 0.3**: Обновлён диспетчер задач для поддержки универсальных hooks (pre/post-команды в exec- и config-режимах). Это позволяет выполнять произвольные команды перед/после основной (например, отключение/включение logging console для избежания засорения вывода). Hooks и pagination теперь обрабатываются в одном файле (dispatcher.py) без дополнительных wrapper-задач. Обоснование: Упрощение расширяемости для разных проектов (сохранение конфигурации, отключение логов и т.д.). Trade-offs: Логика dispatcher стала сложнее, но общее количество файлов/задач уменьшилось; post-команды выполняются всегда (в finally). Рекомендация: Задавайте hooks через platform_config в inventory; комбинируйте с pagination для устройств с большими выводами.
- **Версия 0.2**: Убраны устаревшие примеры (get_instance, get_host_result). Добавлена поддержка пагинации в inventory. Уточнена сигнатура run_commands (только str, без List[str]). Добавлены детали обработки ошибок для пагинации.
- **Версия 0.1**: Исходный PRD с Singleton-обёрткой.

---